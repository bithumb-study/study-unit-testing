# Chapter 11. 단위 테스트 안티 패턴

- 비공개 메서드 단위 테스트
- 단위 테스트를 하기 위한 비공개 메서드 노출
- 테스트로 유출된 도메인 지식
- 구체 클래스 목 처리

## 11.1 비공개 메서드 단위 테스트

- 짧게 요약하면 ‘전혀 하지 말아야 한다’

### 11.1.1 비공개 메서드와 테스트 취약성

- 단위 테스트를 위해 비공개 메서드를 노출하는 경우 식별할 수 있는 동작만 테스트하는 것을 위반
- 비공개 메서드를 노출하면 테스트가 구현 세부 사항과 결합되고 리팩터링 내석이 떨어짐
- 비공개 메서드는 간접적으로 테스트하는 것이 좋음

### 11.1.2 비공개 메서드와 불필요한 커버리지

식별할 수 있는 동작에 이미 합리적인 테스트 커버리지가 있다면 다음 두 가지 문제가 발생

- 죽은 코드. 테스트에서 벗어난 코드가 어디에도 사용되지 않는다면 리팩터링 후에도 남아서 관계없는 코드일 수 있다.
- 추상화 누락. 비공개 메서드가 너무 복잡하면 별도의 클래스로 도출해야 하는 추상화가 누락됐다는 징후

## 11.2 비공개 상태 노출

- 단위 테스트 목적으로만 비공개 상태를 노출하는 것은 안티 패턴이다
- 테스트 유의성을 위해 공개  API 노출 영역을 넓히는 것은 좋지 않은 관습이다.

## 11.3 테스트로 유출된 도메인 지식

- 간단한 알고리즘의 예

```java
public static int add(int a, int b){
  return a+b;
}
```

- 알고리즘 테스트 예

```java
public void add_two_numbers(){
  int a = 1;
  int b = 1;
  int expect = a+b;

  int actual = Calculator.add(a,b); // 의미없는 알고리즘 복사 테스트

  Assert.Equal(expect, actual);
}
```

- 위의 예제는 단순한 예이지만 복잡한 알고리즘을 다루는 테스트에도 위와 같은 현상이 발생
- 단순한 제품코드 복사,붙혀넣기
- 이러한 테스트는 리팩터링 내성에서 0점이 되고 가치가 없다
- 또한 타당한 실패와 거짓 양성을 구별할 가능성이 없음
- 올바른 알고리즘 테스트 예제

```java
public void add_two_numbers(int a, int b, int expect){

  int actual = Calculator.add(a,b);

  Assert.Equal(expect, actual);
}
```

- 단위 테스트에서는 예상 결과를 하드코딩하는 것이 좋다

## 11.4 코드 오염

- 코드 오염은 테스트에만 필요한 제품 코드를 추가하는 것
- 코드 오염의 문제는 테스트 코드와 제품 코드가 혼재돼 유지비가 증가하는 것
- 이러한 안티 패턴을 방지하려면 테스트 코드를 제품 코드베이스와 분리

## 11.5 구체 클래스를 목으로 처리하기

- 구체 클래스를 목으로 처리하여 본래 클래스의 기능 일부를 보존할 수 있으며 때때로 유용, 하지만 단일 책임 원칙을 위배하는 중대한 단점이 있음
- 일부 기능을 지키려고 구체 클래스를 목으로 처리해야 하면, 이는 단일 책임 원칙을 위반하는 결과

## 11.6 시간 처리하기

- 코드 베이스에 시간 의존성이 들어간 경우 단위 테스트에서 어떻게 처리하는지 소개

### 11.6.1 앰비언트 컨텍스트로서의 시간

- 시간을 앰비언트 컨텍스트로 사용하는 것은 안티 패턴
- 제품 코드를 오염시키고 테스트를 더 어렵게 함

### 11.6.2 명시적 의존성으로서의 시간

- 서비스 또는 일반 값으로 시간 의존성을 명시적으로 주입하는 방법
- 그 중에서도 서비스 보단 값으로 주입하는 것이 더 좋음

## 11.7 결론

- 이 책을 통해 좋은 테스트의 4대 요소를 사용해 그 사례를 분석
- 저자 블로그 [https://enterprisecraftsmanship.com/](https://enterprisecraftsmanship.com/)